В текущей реализации проекта мы использовали подход к структуре директорий, который разделяет приложение на логические слои или архитектурные модули, то есть придерживаемся **многоуровневой (слоистой) архитектуры**. Этот подход делит код на слои с четким разграничением ответственности, улучшает модульность, тестируемость и облегчаем поддержку и расширение кода.
В частности, структура директорий в проекте выглядит примерно так:
## **Структура директорий**
``` 
src/main/java/com/example/scheduler/
├── adapters/         # Адаптеры (внешние интерфейсы, API, REST) 
│   ├── dto/          # DTO (Data Transfer Objects) для передачи данных
│   ├── web/          # REST-контроллеры (веб-слой)
│   ├── mapper/       # Опционально: мапперы DTO ↔ доменные объекты
├── application/      # Приложение (слой Use Cases, бизнес-логика)
│   ├── service/      # Сервисы доменной логики
│   ├── usecase/      # Сценарии использования (Use Cases)
├── domain/           # Доменная модель (основная бизнес-логика)
│   ├── model/        # Сущности и объекты домена (например, Event, Booking)
│   ├── repository/   # Интерфейсы репозиториев для работы с базой данных
│   ├── exception/    # Исключения, специфичные для доменной логики (опционально)
├── infrastructure/   # Инфраструктура
│   ├── config/       # Конфигурация Spring, Security и т.д.
│   ├── repository/   # Реализация работы с базой данных
│   ├── security/     # Логика безопасности (например, JWT)
```
### Основная идея структуры
Мы следуем принципам **чистой архитектуры (Clean Architecture)** и **гексагональной архитектуры (Hexagonal Architecture)**, где делаем приложение независимым от фреймворков и инфраструктуры (насколько это возможно). Каждый слой отвечает только за свою часть задачи.
### **Слои проекта и их назначение**
#### **1. Adapters (внешний слой)**
Этот слой — "внешние интерфейсы" нашей системы. Он работает с внешним миром: HTTP-запросами (REST API), UI или сервисами интеграции.
Внутри этого слоя:
- **`web/`** содержит REST-контроллеры, которые принимают входные запросы, вызывают бизнес-логику и возвращают ответы.
- **`dto/`** — Data Transfer Objects (DTOs), классы для обмена данными между различными слоями (например, параметры REST-запросов или ответы).
- **`mapper/`** (если нужен) — классы для преобразования DTO ↔ доменные объекты (`Event`, `Booking`, и т.д.), чтобы скрыть детали внутренней реализации.

#### **Пример**
- REST-контроллер `BookingController` принимает HTTP-запрос, преобразует его в DTO и передает в `Use Case` в слое `application`.
- Ответ (например, результат бронирования) преобразуется из доменной сущности в объект DTO для ответа клиенту.

#### **2. Application (слой бизнес-логики и сценариев использования)**
Этот слой отвечает за реализацию бизнес-процессов, то есть непосредственно **сценариев использования (use cases)**. Именно здесь мы связываем действия пользователя и основную бизнес-логику.
В слое `application`:
- **`usecase/`**: Каждый сценарий использования (например, "Создать запись", "Удалить запись") оформляется в отдельный **Use Case**.
- **`service/`**: Доменные/технические сервисы, которые содержат общую или переиспользуемую логику (например, работа с пользователями).

#### **Пример**
Сценарий использования `BookSlotUseCase`:
- Получает запрос из контроллера и передает его в доменный слой.
- Проверяет необходимые условия ("Слот доступен?", "Пользователь авторизован?").
- Вызывает репозиторий для создания брони или сохранения данных.

#### **3. Domain (бизнес-домен, "сердце" проекта)**
Доменный слой — это самая важная часть приложения, где описывается основная бизнес-логика.
Внутри доменного слоя:
- **`model/`** — доменные модели и сущности, например, `Event`, `Slot`, `Booking`. Каждая модель представлена как объект с полями и методами.
- **`repository/`** — интерфейсы, которые описывают, как работать с базой данных или внешними источниками данных. Реальные реализации этих интерфейсов находятся в слое инфраструктуры.
- **`exception/`** — исключения, специфичные для доменной логики (например, "Слот недоступен").

#### **Пример**
- Класс `Booking` описывает сущность бронирования: свойства ID, ID слота, статус ("забронирован/отменен").
- В интерфейсе `SlotRepository` определяется метод `updateSlotAsBooked(Long slotId)`, но конкретная реализация этого метода скрыта от доменного слоя.

#### **4. Infrastructure (технические детали, инфраструктура)**
Этот слой работает с фреймворками и конкретной инфраструктурой — базой данных, безопасностью, внешними сервисами.
Разделы инфраструктурного слоя:
- **`config/`** — конфигурация фреймворков (Spring, JWT, Hibernate и т.д.).
- **`repository/`** — реализация интерфейсов репозиториев. Например, связь с базой данных через `JPA`, `JDBC` или другой инструмент.
- **`security/`** — управление безопасностью (например, аутентификация через JWT, фильтры безопасности).

#### **Пример**
- В слое `infrastructure.repository` находится реализация интерфейса `BookingRepository`, которая работает с базой данных.
- Класс `JwtTokenProvider` в `infrastructure.security` реализует логику создания и парсинга JWT-токенов.

### **Принципы подхода**
1. **Разделение ответственности (Separation of Concerns):**
    - Обеспечивает, что код с одной задачей (например, API) не смешивается с кодом другой задачи (например, логики домена).

2. **Модульность:**
    - Каждый слой независим от других, что делает тестирование, модификацию и расширение проще.

3. **Тестируемость:**
    - Логика домена и сценариев использования может быть протестирована отдельно от деталей инфраструктуры (например, базы данных).

4. **Зависимости сверху вниз:**
    - Верхние слои, такие как `adapters`, зависят от нижних слоев (`application` и `domain`), но не наоборот.
    - Например, домен не знает про REST-контроллеры или DTO.

### **Пример зависимости между слоями**
- **`adapters.web`** вызывает `application.usecase`, передает в нее DTO.
- **`application.usecase`** оперирует доменными моделями из **`domain`**.
- **`domain.repository`** интерфейсы вызываются из **`infrastructure.repository`**, чтобы остальной проект не зависел от реализации базы данных.

### Почему этот подход удобен?
1. **Масштабируемость:** Можно легко добавлять новые функции, привязывать новые API или сервисы.
2. **Гибкость:** Доменные модели легко адаптировать к различным интерфейсам (REST, GraphQL, gRPC).
3. **Изоляция доменного слоя:** Основные бизнес-правила не зависят от конкретных технологий и легко тестируются.
4. **Простота чтения:** Каждый слой имеет четко определенную ответственность, что позволяет легко ориентироваться в проекте.
